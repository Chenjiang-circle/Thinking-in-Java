# Java核心技术卷一
## 第四章 对象与类
### 类
实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
### 对象
想要使用OOP，一定要清楚对象的三个主要特征：
- 对象的行为（behavior）
- 对象的状态（statue）
- 对象的标识（identity）

对象的状态必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）
### 类之间的关系
在类之间，最常见的关系有：
- 依赖
- 聚合
- 继承

应该尽可能地将相互依赖的类减至最少。如果类Ａ不知道Ｂ的存在，它就不会关心Ｂ的任何改变。用软件工程的术语来说，就是让类之间的耦合度最小。

**聚合**，即“has-a”关系，是一种具体且易于理解的关系。聚合关系意味着类A的对象包含类B的对象。
### 使用预定义类
一定要认识到：一个变量并没有实际包含一个对象，而仅仅引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个**引用**

局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化。
所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

> 在c++中，带有const后缀的方法是访问器**方法**；默认为更改器方法。但是，在Java语言中，访问器与更改器方法在语法上没有明显的区别。
### 用户自定义类
在一个源文件中，只能有一个共有类，但是可以有任意数目的非共有类。

两个单独的源文件：Employee.java和EmployeeTest.java。有两种方法可以编译源程序：
- 一种是使用通配符调用Java编译器：`javac Employee*.java`。这样，所有与通配符匹配的源文件都将被编译成类文件。
- 另一种是键入命令：`javac EmployeeTest.java`。使用这种方法，并没有显式地编译Employee.java。然而，当Java编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件。如果没有找到这个文件，就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有Employee.java文件版本新，Java编译器就会自动地重新编译这个文件。
构造器总是伴随着new操作符的执行被调用，而不能对一个已存在的对象调用构造器来达到重新设置实例域的目的。
> 注意：不要在构造器中定义与实例域重名的局部变量！

```java
public void taiseSalary(double byPercent)
{
    double raise = salary * byPercent / 100;
    salary += raise;
}
```

raise方法有两个参数。第一个参数称为隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面的括号中的数值，这是一个显式参数。（有些人把隐式参数称为方法调用的目标或接受者。）

在每一个方法中，关键字this表示隐式参数。如果需要的话，可以用下列方法编写raiseSalary方法：

```java
public void raiseSalary(double byPercent)
{
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
```
如果需要返回一个可变对象的引用，应该首先对它进行克隆，**对象克隆**是指存放在另一个位置上的对象副本。

### 静态域与静态方法
### 方法参数
“按......调用”（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言中方法参数的传递方式。

Java程序设计语言总是采用**按值调用**。也就是说，方法得到的是所有参数值的一个拷贝，特别是，**方法不能修改传递给它的任何参数变量的内容**。

### 对象构造
如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为**重载解析（overloading resolution)**。）

Java允许重载方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的**签名（signature)** 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。

如果构造器的第一个语句形如 `this(...)`， 这个构造器将调用同一个类的另一个构造器。下
面是一个典型的例子：
```java
public Employee(double s)
{
// calls Employee(String, double)
this("Employee #" + nextld, s);
nextld++;
}
```
当调用 `new Employee(60000)` 时， `Employee(double)` 构造器将调用 `Employee(String，double)`构造器。

由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：
1. 所有数据域被初始化默认值（0、false和null）
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

### 包
使用包的主要原因是确保类名的唯一性。

import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。例如，如果在源文件的顶部，加上一条指令：`import static java.lang.Sytem.*;`就可以使用System类的静态方法和静态域，而不必加类名前缀：<br>`out.println("Good")`<br>`exit(0)`<br>另外还可以导入特定的方法或域：`inport static java.lang.Sytem.out;`

标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用。如果没有制定public或private，这个部分可以被同一个包中的所有方法访问。

### 文档注释
如果在源代码中添加以专用的定界符`/**`开始的注释， 那么可以很容易地生成一个看上
去具有专业水准的文档。

**注释抽取**<br>可以使用多种形式的命令行选项对 javadoc 程序进行调整。例如， 可以使用 -author 和
-version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省
略)。另一个很有用的选项是 `-link`, 用来为标准类添加超链接。例如， 如果使用命令
`javadoc -link http://docs.oracle.eom/:javase/8/docs/api *.java` 那么，所有的标准类库类都会自动地链接到 Oracle 网站的文档。如果使用 `-linksource` 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号，) 并且每个类和方法名将转变为指向源代码的超链接。

### 类设计技巧
1. 一定要保证数据私有。
2. 一定要对数据初始化。
3. 不要在类中使用过多的基本类型。
4. 不是所有的域都需要独立的域访问器和域更改器。
5. 将职责过多的类进行分解。
6. 类名和方法名要能够体现它们的职责。
7. 优先使用不可变的类。

## 第五章 继承
### 类、超类和子类
关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类、基类或者父类；新类称为子类、派生类或者孩子类。超类和子类是Java程序员最常用的两个术语。

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中，这种将通用的
功能放到超类的做法，在面向对象程序设计中十分普遍。

需要指出：我们希望调用超类中的方法，而不是当前类的这个方法。为此，可以使用特定的关键字`super`解决这个问题。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器（没有参数的构造器）。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。

一个对象变量可以指示多种实际类型的现象被称为**多态**。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定**。

有一个判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的地方都可以用子类对象置换。