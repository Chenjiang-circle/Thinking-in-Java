# Java核心技术卷一
## 第四章 对象与类
### 类
实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
### 对象
想要使用OOP，一定要清楚对象的三个主要特征：
- 对象的行为（behavior）
- 对象的状态（statue）
- 对象的标识（identity）

对象的状态必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）
### 类之间的关系
在类之间，最常见的关系有：
- 依赖
- 聚合
- 继承

应该尽可能地将相互依赖的类减至最少。如果类Ａ不知道Ｂ的存在，它就不会关心Ｂ的任何改变。用软件工程的术语来说，就是让类之间的耦合度最小。

**聚合**，即“has-a”关系，是一种具体且易于理解的关系。聚合关系意味着类A的对象包含类B的对象。
### 使用预定义类
一定要认识到：一个变量并没有实际包含一个对象，而仅仅引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个**引用**

局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化。
所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

> 在c++中，带有const后缀的方法是访问器**方法**；默认为更改器方法。但是，在Java语言中，访问器与更改器方法在语法上没有明显的区别。
### 用户自定义类
在一个源文件中，只能有一个共有类，但是可以有任意数目的非共有类。

两个单独的源文件：Employee.java和EmployeeTest.java。有两种方法可以编译源程序：
- 一种是使用通配符调用Java编译器：`javac Employee*.java`。这样，所有与通配符匹配的源文件都将被编译成类文件。
- 另一种是键入命令：`javac EmployeeTest.java`。使用这种方法，并没有显式地编译Employee.java。然而，当Java编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件。如果没有找到这个文件，就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有Employee.java文件版本新，Java编译器就会自动地重新编译这个文件。
构造器总是伴随着new操作符的执行被调用，而不能对一个已存在的对象调用构造器来达到重新设置实例域的目的。
> 注意：不要在构造器中定义与实例域重名的局部变量！

```java
public void taiseSalary(double byPercent)
{
    double raise = salary * byPercent / 100;
    salary += raise;
}
```

raise方法有两个参数。第一个参数称为隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面的括号中的数值，这是一个显式参数。（有些人把隐式参数称为方法调用的目标或接受者。）

在每一个方法中，关键字this表示隐式参数。如果需要的话，可以用下列方法编写raiseSalary方法：

```java
public void raiseSalary(double byPercent)
{
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
```
如果需要返回一个可变对象的引用，应该首先对它进行克隆，**对象克隆**是指存放在另一个位置上的对象副本。

### 静态域与静态方法
### 方法参数
“按......调用”（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言中方法参数的传递方式。

Java程序设计语言总是采用**按值调用**。也就是说，方法得到的是所有参数值的一个拷贝，特别是，**方法不能修改传递给它的任何参数变量的内容**。

### 对象构造
如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为**重载解析（overloading resolution)**。）

Java允许重载方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的**签名（signature)** 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。

如果构造器的第一个语句形如 `this(...)`， 这个构造器将调用同一个类的另一个构造器。下
面是一个典型的例子：
```java
public Employee(double s)
{
// calls Employee(String, double)
this("Employee #" + nextld, s);
nextld++;
}
```
当调用 `new Employee(60000)` 时， `Employee(double)` 构造器将调用 `Employee(String，double)`构造器。

由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：
1. 所有数据域被初始化默认值（0、false和null）
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

### 包
使用包的主要原因是确保类名的唯一性。

import语句不仅可以导入类，还增加了导入静态方法和静态域的功能。例如，如果在源文件的顶部，加上一条指令：`import static java.lang.Sytem.*;`就可以使用System类的静态方法和静态域，而不必加类名前缀：<br>`out.println("Good")`<br>`exit(0)`<br>另外还可以导入特定的方法或域：`inport static java.lang.Sytem.out;`

标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用。如果没有制定public或private，这个部分可以被同一个包中的所有方法访问。

### 文档注释
如果在源代码中添加以专用的定界符`/**`开始的注释， 那么可以很容易地生成一个看上
去具有专业水准的文档。

**注释抽取**<br>可以使用多种形式的命令行选项对 javadoc 程序进行调整。例如， 可以使用 -author 和
-version 选项在文档中包含@author 和@version 标记（默认情况下，这些标记会被省
略)。另一个很有用的选项是 `-link`, 用来为标准类添加超链接。例如， 如果使用命令
`javadoc -link http://docs.oracle.eom/:javase/8/docs/api *.java` 那么，所有的标准类库类都会自动地链接到 Oracle 网站的文档。如果使用 `-linksource` 选项，则每个源文件被转换为 HTML (不对代码着色，但包含行编号，) 并且每个类和方法名将转变为指向源代码的超链接。

### 类设计技巧
1. 一定要保证数据私有。
2. 一定要对数据初始化。
3. 不要在类中使用过多的基本类型。
4. 不是所有的域都需要独立的域访问器和域更改器。
5. 将职责过多的类进行分解。
6. 类名和方法名要能够体现它们的职责。
7. 优先使用不可变的类。

## 第五章 继承
### 类、超类和子类
关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类、基类或者父类；新类称为子类、派生类或者孩子类。超类和子类是Java程序员最常用的两个术语。

在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中，这种将通用的
功能放到超类的做法，在面向对象程序设计中十分普遍。

需要指出：我们希望调用超类中的方法，而不是当前类的这个方法。为此，可以使用特定的关键字`super`解决这个问题。

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器（没有参数的构造器）。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。

一个对象变量可以指示多种实际类型的现象被称为**多态**。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定**。

有一个判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的地方都可以用子类对象置换。

**方法调用过程**：

假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：<br>
1. 编译器查看对象的声明类型和方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：有可能存在多个名字为f，但参数类型不一样的方法。编译器将会一一列举所有C类中名字为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）
2. 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析**。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。
3. 如果是private方法、static方法、final方法或者构造器，那么编译器就可以准确地知道应该调用哪个方法，我们将这种调用方法称为**静态绑定**。与对应的是，调用方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。
4. 当程序运行，并且采用动态绑定时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会直接调用它；否则，将在D类的超类中寻找f(String)方法，以此类推。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建一个方法表，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。

> 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。

对于final域来说，构造对象之后就不允许改变他们的值了，不过，如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。

如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为**内联**。例如，内联调用e.getName()将被替换成访问e.name域。虚拟机中的及时编译器比传统的编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并且能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正地被覆盖，那么及时编译器就会将这个方法进行内联出处理。

将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行**类型转换**。在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现：
```java
if(staff[1] instanceof Manager)
{
  ...
}
```
包含一个或者多个抽象类的本身必须被声明为抽象的。除了抽象的方法之外，抽象类还可以包含具体的数据和具体方法。类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化，也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。可以定义一个抽象类的对象变量，但是它只能引用一个非抽象子类的对象。

### Object：所有类的超类

在Java中，只有基本类型不是对象，例如，数值、字符和布尔类型的值不是对象，所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。

Java语言规范要求equals方法具有下面的特征：
1. 自反性：对于任何非空引用x，x.equals(x)应该返回true。
2. 对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true。
3. 传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true。
4. 一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回相同的结果。
5. 对于任意非空引用x，x.equals(null)应该返回false。

编写一个完美的equals方法的建议：
1. 显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。
2. 检测this与otherObject是否引用同一个对象：<br>`if(this == otherObject) return true;`<br>这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算一个等式要比一个一个地比较类中的域所付出的代价小得多。
3. 检测otherObject是否为null，如果为null，返回false。这项检测是很有必要的。<br>`if(otherObject == null) return false;`
4. 比较this和otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测：<br>`if (getClass != otherObject.getClass()) return false;`<br>如果所有的子类都拥有统一的语义，就使用instanceof检测：<br>`if(!(otherObject instanceof ClassName)) return false;`
5. 将otherObject转换为对应的类类型变量：<br>`ClassName other = (ClassName) otherObject`
6. 现在开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true；否则返回false。

```java
return field1 == other.field1
  && Object.equals(field2, other.field2)
  && ...;
```
如果在子类中重新定于equals，就要在其中包含调用super.equals(other)。

散列码（hash code）是由对象导出的一个整数值。散列码是没有规律的。如果x和
y是两个不同的对象，x.hashCode()与y.hashCode()基本上不会相同。

String类使用下列算法计算散列码：
```java
int hash = 0;
for(int i = 0; i < length(); i++)
  hash = 31 * hash + charAt(i);
```
由于hashCode方法定义再Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

Object类定义了toString方法，用来打印输出对象所属的类名和散列码。

### 泛型数组列表
一旦能够确认数组列表大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。

使用add方法可以将元素添加到数组列表中。如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中**拷贝**到较大的数组中。

如果已经清楚估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法：

```java
staff.ensureCapacity(100);
```

这个方法调用分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分空间。

> 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配100个元素的存储空间，数组就有100个空位置可以使用。而容量为100个元素的数组列表只是拥有保存100个元素的潜力（实际上，重新分配空间的话，将会超过100），但是在最初，甚至是完成初始化构造之后，数组列表根本就不含有任何元素。

一旦能够确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。**垃圾回收器将回收多余的存储空间**。

一旦能够确保不会造成严重后果，可以用`@SuppressWarnings("unchecked")`标注来标记这个变量能够接受类型转换。

假设想要定义一个整形数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成`ArrayList<int>`。这里就用到了Integer对象包装器类。我们可以声明一个Integer对象数组列表。
```java
ArrayList<Integer> list = new ArrayList<>();
```

> 由于每个值分别包装在对象中，所以`AaarayList<Integer>`的效率远远低于int[]数组。因此，应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更加重要。

大多数情况下，容易有一种假象，即基本类型与它们的对象包装器是意向的，只是它们的相等性不同。大家知道，==运算符页应该可以应用于对象包装器对象，只不过检测的是对象是否指向同一个存储区域，因此，下面的比较通常不会成立：
```java
Integer a = 1000;
Integer b = 1000;
if (a == b)...
```
然而，Java实现却有可能 让它成立。如果将经常出现的值包装到同一个对象中，这种比较就有可能成立。这种不确定的结果并不是我们所希望的。解决这个问题的办法是在两个包装器对象比较时调用equals方法。

装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。

## 参数数量可变的方法

用户自己可以定义可变参数的方法，并将参数指定为任意参数类型，甚至是基本类型。下面是一个简单的实例：
```java
// 计算若干个数值的最大值
public static double max(double... values){
  double largest = Double.NEGATIVE_INFINITY;
  for (double v : values){
    if (v > largest){
      largset = v;
    }
  }
  return largest;
}
```

## 枚举类

