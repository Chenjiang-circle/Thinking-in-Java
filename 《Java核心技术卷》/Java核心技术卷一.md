# Java核心技术卷一
## 第四章 对象与类
### 类
实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。
### 对象
想要使用OOP，一定要清楚对象的三个主要特征：
- 对象的行为（behavior）
- 对象的状态（statue）
- 对象的标识（identity）

对象的状态必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）
### 类之间的关系
在类之间，最常见的关系有：
- 依赖
- 聚合
- 继承

应该尽可能地将相互依赖的类减至最少。如果类Ａ不知道Ｂ的存在，它就不会关心Ｂ的任何改变。用软件工程的术语来说，就是让类之间的耦合度最小。

**聚合**，即“has-a”关系，是一种具体且易于理解的关系。聚合关系意味着类A的对象包含类B的对象。
### 使用预定义类
一定要认识到：一个变量并没有实际包含一个对象，而仅仅引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个**引用**

局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化。
所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。

> 在c++中，带有const后缀的方法是访问器**方法**；默认为更改器方法。但是，在Java语言中，访问器与更改器方法在语法上没有明显的区别。
### 用户自定义类
在一个源文件中，只能有一个共有类，但是可以有任意数目的非共有类。

两个单独的源文件：Employee.java和EmployeeTest.java。有两种方法可以编译源程序：
- 一种是使用通配符调用Java编译器：`javac Employee*.java`。这样，所有与通配符匹配的源文件都将被编译成类文件。
- 另一种是键入命令：`javac EmployeeTest.java`。使用这种方法，并没有显式地编译Employee.java。然而，当Java编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件。如果没有找到这个文件，就会自动地搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有Employee.java文件版本新，Java编译器就会自动地重新编译这个文件。
构造器总是伴随着new操作符的执行被调用，而不能对一个已存在的对象调用构造器来达到重新设置实例域的目的。
> 注意：不要在构造器中定义与实例域重名的局部变量！

```java
public void taiseSalary(double byPercent)
{
    double raise = salary * byPercent / 100;
    salary += raise;
}
```

raise方法有两个参数。第一个参数称为隐式参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面的括号中的数值，这是一个显式参数。（有些人把隐式参数称为方法调用的目标或接受者。）

在每一个方法中，关键字this表示隐式参数。如果需要的话，可以用下列方法编写raiseSalary方法：

```java
public void raiseSalary(double byPercent)
{
    double raise = this.salary * byPercent / 100;
    this.salary += raise;
}
```
如果需要返回一个可变对象的引用，应该首先对它进行克隆，**对象克隆**是指存放在另一个位置上的对象副本。

### 静态域与静态方法
### 方法参数
“按......调用”（call by）是一个标准的计算机科学术语，它用来描述各种程序设计语言中方法参数的传递方式。

Java程序设计语言总是采用**按值调用**。也就是说，方法得到的是所有参数值的一个拷贝，特别是，**方法不能修改传递给它的任何参数变量的内容**。

### 对象构造
如果多个方法（比如， StringBuilder 构造器方法）有相同的名字、 不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为**重载解析（overloading resolution)**。）

Java允许重载方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的**签名（signature)** 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。

如果构造器的第一个语句形如 `this(...)`， 这个构造器将调用同一个类的另一个构造器。下
面是一个典型的例子：
```java
public Employee(double s)
{
// calls Employee(String, double)
this("Employee #" + nextld, s);
nextld++;
}
```
当调用 `new Employee(60000)` 时， `Employee(double)` 构造器将调用 `Employee(String，double)`构造器。

由于初始化数据域有多种途径，所以列出构造过程的所有路径可能相当混乱。下面是调用构造器的具体处理步骤：
1. 所有数据域被初始化默认值（0、false和null）
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

